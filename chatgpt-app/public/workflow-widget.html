<!DOCTYPE html>
<html lang="da">
<head>
	<meta charset="utf-8" />
	<title>Workflow Wizard Widget</title>
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<style>
		:root {
			font-family: 'Segoe UI', system-ui, sans-serif;
			background: #f8fafc;
			color: #0f172a;
		}
		body {
			margin: 0;
			padding: 1rem;
		}
		.container {
			display: flex;
			flex-direction: column;
			gap: 0.75rem;
		}
		label {
			font-size: 0.85rem;
			font-weight: 600;
			display: flex;
			flex-direction: column;
			gap: 0.25rem;
		}
		input, select, textarea, button {
			font: inherit;
		}
		input, select, textarea {
			padding: 0.5rem;
			border: 1px solid #cbd5f5;
			border-radius: 0.5rem;
			background: #fff;
		}
		textarea {
			min-height: 5rem;
			resize: vertical;
		}
		button {
			border: none;
			border-radius: 0.5rem;
			padding: 0.6rem 1rem;
			background: #0f172a;
			color: #fff;
			font-weight: 600;
			cursor: pointer;
		}
		button.secondary {
			background: #475569;
		}
		button:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}
		.actions {
			display: flex;
			flex-wrap: wrap;
			gap: 0.5rem;
		}
		.project-section {
			display: flex;
			flex-direction: column;
			gap: 0.25rem;
		}
		.project-controls {
			display: flex;
			flex-wrap: wrap;
			gap: 0.5rem;
			align-items: center;
		}
		.project-controls select {
			flex: 1 1 10rem;
		}
		.new-project {
			display: flex;
			flex-wrap: wrap;
			gap: 0.5rem;
		}
		.new-project input {
			flex: 1 1 12rem;
		}
		.hidden {
			display: none !important;
		}
		.fields-section {
			border: 1px solid #e2e8f0;
			border-radius: 0.75rem;
			padding: 0.75rem;
			background: #fff;
		}
		.fields-header {
			font-size: 0.85rem;
			font-weight: 600;
			margin-bottom: 0.5rem;
		}
		.fields-grid {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}
		.field-item {
			display: flex;
			flex-direction: column;
			gap: 0.35rem;
		}
		.field-item span {
			font-size: 0.8rem;
			color: #475569;
		}
		.field-item textarea {
			min-height: 4rem;
		}
		.status {
			font-size: 0.8rem;
			color: #059669;
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="project-section">
			<label>
				Projekt
				<div class="project-controls">
					<select id="projectSelect">
						<option value="">Vælg projekt</option>
					</select>
					<button id="createProjectBtn" type="button">Opret</button>
					<button id="deleteProjectBtn" type="button" class="secondary" disabled>Slet</button>
				</div>
			</label>
			<div id="newProjectForm" class="new-project hidden">
				<input id="newProjectName" placeholder="Nyt projektnavn" />
				<button id="saveProjectBtn" type="button">Gem projekt</button>
			</div>
		</div>

		<label>
			Project name (valgfrit)
			<input id="projectName" placeholder="fx Workflow Wizard" readonly />
		</label>

		<label>
			Type
			<select id="kind">
				<option value="bug">Bug</option>
				<option value="feature" selected>Feature</option>
				<option value="enhancement">Enhancement</option>
				<option value="ui">UI design update</option>
			</select>
		</label>

		<label>
			Paste specs
			<textarea id="pastedText" placeholder="Indsæt din beskrivelse her..."></textarea>
		</label>

		<button id="parseBtn" type="button" class="secondary">Parse & udfyld</button>

		<div class="fields-section">
			<div class="fields-header">Felter</div>
			<div id="fields" class="fields-grid"></div>
		</div>

		<button id="generateBtn">Generate</button>

		<label>
			Output
			<textarea id="output" readonly></textarea>
		</label>

		<div class="actions">
			<button id="copyBtn" type="button" class="secondary">Copy output</button>
			<button id="followUpBtn" type="button" class="secondary">Copy output as message</button>
		</div>

		<div id="status" class="status"></div>
	</div>

	<script>
		(() => {
			const kindSelect = document.getElementById('kind');
			const projectInput = document.getElementById('projectName');
			const pasteInput = document.getElementById('pastedText');
			const outputArea = document.getElementById('output');
			const statusEl = document.getElementById('status');
			const parseBtn = document.getElementById('parseBtn');
			const fieldsContainer = document.getElementById('fields');
			const projectSelect = document.getElementById('projectSelect');
			const createProjectBtn = document.getElementById('createProjectBtn');
			const deleteProjectBtn = document.getElementById('deleteProjectBtn');
			const newProjectForm = document.getElementById('newProjectForm');
			const newProjectInput = document.getElementById('newProjectName');
			const saveProjectBtn = document.getElementById('saveProjectBtn');
			const PROJECTS_KEY = 'copilotflow_projects_v1';
			const ACTIVE_PROJECT_KEY = 'copilotflow_active_project_v1';
			const fieldDefinitions = {
				bug: [
					{ key: 'bugId', label: 'Bug ID', type: 'text' },
					{ key: 'title', label: 'Titel', type: 'text' },
					{ key: 'goal', label: 'Mål', type: 'textarea' },
					{ key: 'repro', label: 'Repro', type: 'textarea' },
					{ key: 'expected', label: 'Forventet', type: 'textarea' },
					{ key: 'actual', label: 'Faktisk', type: 'textarea' },
					{ key: 'scope', label: 'Scope', type: 'textarea' },
					{ key: 'constraints', label: 'Constraints', type: 'textarea' },
					{ key: 'filesInserted', label: 'Indsatte filer', type: 'textarea' },
				],
				feature: [
					{ key: 'featureId', label: 'Feature ID', type: 'text' },
					{ key: 'title', label: 'Titel', type: 'text' },
					{ key: 'goal', label: 'Mål', type: 'textarea' },
					{ key: 'scope', label: 'Scope', type: 'textarea' },
					{ key: 'constraints', label: 'Constraints', type: 'textarea' },
					{ key: 'filesInserted', label: 'Indsatte filer', type: 'textarea' },
				],
				enhancement: [
					{ key: 'featureId', label: 'Feature ID', type: 'text' },
					{ key: 'title', label: 'Titel', type: 'text' },
					{ key: 'goal', label: 'Mål', type: 'textarea' },
					{ key: 'scope', label: 'Scope', type: 'textarea' },
					{ key: 'constraints', label: 'Constraints', type: 'textarea' },
					{ key: 'filesInserted', label: 'Indsatte filer', type: 'textarea' },
				],
				ui: [
					{ key: 'featureId', label: 'UI / Feature ID', type: 'text' },
					{ key: 'title', label: 'Titel', type: 'text' },
					{ key: 'goal', label: 'Mål', type: 'textarea' },
					{ key: 'scope', label: 'Scope', type: 'textarea' },
					{ key: 'constraints', label: 'Constraints', type: 'textarea' },
					{ key: 'filesInserted', label: 'Indsatte filer', type: 'textarea' },
					{ key: 'designNotes', label: 'Design notes', type: 'textarea' },
				],
			};
			const sectionLabels = {
				goal: ['Mål', 'Goal', 'Objective'],
				repro: ['Repro', 'Reproduktion', 'Steps to reproduce'],
				expected: ['Forventet', 'Expected'],
				actual: ['Faktisk', 'Actual'],
				scope: ['Scope'],
				constraints: ['Constraints', 'Krav', 'Begrænsninger'],
				filesInserted: ['Filer', 'Files', 'Affected files', 'Indsatte filer'],
				designNotes: ['Design', 'UI', 'Mock', 'Design notes'],
			};
			const values = {};
			let projects = [];
			let activeProjectId = null;
			const checklist =
				'✅ NÆSTE SKRIDT\n' +
				'1. Indsæt ændrede filer til validering.\n' +
				'2. Kør lokale tests / build.\n' +
				'3. Notér observationer & logs.\n' +
				'4. Commit med passende besked.\n' +
				'5. Del status og næste skridt.';

			const headerLabels = {
				bug: 'BUG PROMPT',
				feature: 'FEATURE PROMPT',
				enhancement: 'ENHANCEMENT PROMPT',
				ui: 'UI DESIGN PROMPT',
			};

			const setStatus = (text, isError = false) => {
				statusEl.textContent = text;
				statusEl.style.color = isError ? '#dc2626' : '#059669';
				if (!text) return;
				setTimeout(() => {
					if (statusEl.textContent === text) statusEl.textContent = '';
				}, 4000);
			};

			const updateOutput = (text) => {
				outputArea.value = text ?? '';
			};

			const getFieldDefs = (kind) => fieldDefinitions[kind] ?? [];

			const renderFields = (kind) => {
				const defs = getFieldDefs(kind);
				const allowedKeys = new Set(defs.map((def) => def.key));
				Object.keys(values).forEach((key) => {
					if (!allowedKeys.has(key)) delete values[key];
				});
				defs.forEach((def) => {
					if (!(def.key in values)) values[def.key] = '';
				});
				fieldsContainer.innerHTML = '';
				defs.forEach((def) => {
					const wrapper = document.createElement('label');
					wrapper.className = 'field-item';
					const span = document.createElement('span');
					span.textContent = def.label;
					const control = def.type === 'textarea' ? document.createElement('textarea') : document.createElement('input');
					if (def.type !== 'textarea') control.type = 'text';
					control.value = values[def.key] ?? '';
					control.addEventListener('input', (event) => {
						values[def.key] = event.target.value;
					});
					wrapper.appendChild(span);
					wrapper.appendChild(control);
					fieldsContainer.appendChild(wrapper);
				});
			};

			const trimValue = (value) => (value ?? '').toString().trim();

			const getTrimmedValues = () => {
				const entries = Object.entries(values)
					.map(([key, value]) => [key, trimValue(value)])
					.filter(([, val]) => val.length > 0);
				return Object.fromEntries(entries);
			};

			const escapeRegex = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

			const parsePasted = (kind, text) => {
				const defs = getFieldDefs(kind);
				const allowedKeys = new Set(defs.map((def) => def.key));
				const result = {};
				if (!text || !text.trim()) return result;
				const lines = text.split(/\r?\n/);
				const firstLine = lines[0]?.trim();
				const idKey = kind === 'bug' ? 'bugId' : 'featureId';
				if (firstLine && allowedKeys.has(idKey)) {
					const idMatch = firstLine.match(/^([A-Za-z]+-\d+)\s*[:\-–]\s*(.+)$/);
					if (idMatch) {
						result[idKey] = idMatch[1].trim();
						const title = idMatch[2]?.trim();
						if (title && allowedKeys.has('title')) {
							result.title = title;
						}
					}
				}

				const sectionMatchers = Object.entries(sectionLabels)
					.filter(([key]) => allowedKeys.has(key))
					.map(([key, labels]) => ({
						key,
						patterns: labels.map((label) => new RegExp(`^${escapeRegex(label)}\\s*[:：\\-–—]?\\s*(.*)$`, 'i')),
					}));

				const flush = (key, buffer) => {
					if (key && buffer.length) {
						const textValue = buffer.join('\n').trim();
						if (textValue) result[key] = textValue;
					}
				};

				let currentKey = null;
				let buffer = [];

				for (const rawLine of lines) {
					const line = rawLine.trimEnd();
					let matched = false;
					for (const matcher of sectionMatchers) {
						for (const pattern of matcher.patterns) {
							const match = line.match(pattern);
							if (!match) continue;
							flush(currentKey, buffer);
							currentKey = matcher.key;
							buffer = [];
							const immediate = (match[1] ?? '').trim();
							if (immediate) buffer.push(immediate);
							matched = true;
							break;
						}
						if (matched) break;
					}
					if (!matched && currentKey) {
						buffer.push(line);
					}
				}

				flush(currentKey, buffer);
				return result;
			};

			renderFields(kindSelect.value);

			const safeReadJSON = (key, fallback) => {
				try {
					const raw = window.localStorage?.getItem?.(key);
					if (!raw) return fallback;
					return JSON.parse(raw);
				} catch (error) {
					console.warn('Storage read failed', error);
					return fallback;
				}
			};

			const safeWriteJSON = (key, value) => {
				try {
					window.localStorage?.setItem?.(key, JSON.stringify(value));
				} catch (error) {
					console.warn('Storage write failed', error);
				}
			};

			const loadProjects = () => safeReadJSON(PROJECTS_KEY, []);
			const saveProjects = (nextProjects) => safeWriteJSON(PROJECTS_KEY, nextProjects);

			const loadActiveProjectId = () => {
				try {
					return window.localStorage?.getItem?.(ACTIVE_PROJECT_KEY) ?? null;
				} catch (error) {
					console.warn('Active project read failed', error);
					return null;
				}
			};

			const saveActiveProjectId = (id) => {
				try {
					const storage = window.localStorage;
					if (!storage) return;
					if (id) {
						storage.setItem(ACTIVE_PROJECT_KEY, id);
					} else {
						storage.removeItem(ACTIVE_PROJECT_KEY);
					}
				} catch (error) {
					console.warn('Active project write failed', error);
				}
			};

			const generateProjectId = () => {
				if (window.crypto?.randomUUID) return window.crypto.randomUUID();
				return `proj-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
			};

			const getActiveProject = () => projects.find((project) => project.id === activeProjectId) ?? null;

			const syncProjectNameField = () => {
				const activeProject = getActiveProject();
				projectInput.value = activeProject?.name ?? '';
				projectInput.placeholder = activeProject ? '' : 'Vælg eller opret et projekt';
			};

			const renderProjectsUI = () => {
				projectSelect.innerHTML = '';
				const placeholderOption = document.createElement('option');
				placeholderOption.value = '';
				placeholderOption.textContent = 'Vælg projekt';
				projectSelect.appendChild(placeholderOption);
				projects.forEach((project) => {
					const option = document.createElement('option');
					option.value = project.id;
					option.textContent = project.name;
					projectSelect.appendChild(option);
				});
				projectSelect.value = activeProjectId ?? '';
				deleteProjectBtn.disabled = !activeProjectId;
				syncProjectNameField();
			};

			const setActiveProject = (id) => {
				if (id && projects.some((project) => project.id === id)) {
					activeProjectId = id;
				} else {
					activeProjectId = null;
				}
				saveActiveProjectId(activeProjectId);
				renderProjectsUI();
			};

			const toggleNewProjectForm = (shouldShow) => {
				if (shouldShow) {
					newProjectForm.classList.remove('hidden');
					newProjectInput.focus();
				} else {
					newProjectForm.classList.add('hidden');
					newProjectInput.value = '';
				}
			};

			const handleSaveProject = () => {
				const name = newProjectInput.value.trim();
				if (!name) {
					setStatus('Angiv projektnavn', true);
					newProjectInput.focus();
					return;
				}
				const newProject = {
					id: generateProjectId(),
					name,
					createdAt: new Date().toISOString(),
				};
				projects = [...projects, newProject];
				saveProjects(projects);
				setActiveProject(newProject.id);
				toggleNewProjectForm(false);
				setStatus('Projekt oprettet');
			};

			const handleDeleteProject = () => {
				const activeProject = getActiveProject();
				if (!activeProject) return;
				const confirmed = window.confirm(`Slet projekt "${activeProject.name}"?`);
				if (!confirmed) return;
				projects = projects.filter((project) => project.id !== activeProject.id);
				saveProjects(projects);
				if (activeProjectId === activeProject.id) {
					setActiveProject(null);
				} else {
					renderProjectsUI();
				}
				setStatus('Projekt slettet');
			};

			const initializeProjects = () => {
				projects = loadProjects();
				activeProjectId = loadActiveProjectId();
				if (!projects.some((project) => project.id === activeProjectId)) {
					activeProjectId = null;
					saveActiveProjectId(null);
				}
				renderProjectsUI();
			};

			initializeProjects();

			createProjectBtn.addEventListener('click', () => {
				const shouldShow = newProjectForm.classList.contains('hidden');
				toggleNewProjectForm(shouldShow);
			});

			saveProjectBtn.addEventListener('click', handleSaveProject);

			newProjectInput.addEventListener('keydown', (event) => {
				if (event.key === 'Enter') {
					event.preventDefault();
					handleSaveProject();
				}
			});

			deleteProjectBtn.addEventListener('click', handleDeleteProject);

			projectSelect.addEventListener('change', (event) => {
				setActiveProject(event.target.value || null);
			});

			kindSelect.addEventListener('change', () => {
				renderFields(kindSelect.value);
			});

			parseBtn.addEventListener('click', () => {
				const text = pasteInput.value;
				if (!text.trim()) {
					setStatus('Indsæt specs først', true);
					return;
				}
				const parsed = parsePasted(kindSelect.value, text);
				let applied = false;
				Object.entries(parsed).forEach(([key, value]) => {
					const trimmedValue = (value ?? '').trim();
					if (trimmedValue) {
						values[key] = trimmedValue;
						applied = true;
					}
				});
				renderFields(kindSelect.value);
				if (applied) {
					setStatus('Felter udfyldt – tjek og ret hvis nødvendigt');
				} else {
					setStatus('Kunne ikke parse felter', true);
				}
			});

			const hydrateFromToolOutput = (toolOutput) => {
				if (!toolOutput) return;
				let kindChanged = false;
				if (toolOutput.kind && kindSelect.value !== toolOutput.kind) {
					kindSelect.value = toolOutput.kind;
					kindChanged = true;
				}
				if (typeof toolOutput.outputText === 'string') {
					updateOutput(toolOutput.outputText);
				}
				if (kindChanged) {
					renderFields(kindSelect.value);
				}
			};

			const extractToolOutput = (detail) => {
				if (!detail) return undefined;
				return detail.globals?.toolOutput ?? detail.toolOutput;
			};

			if (window.openai?.toolOutput) {
				hydrateFromToolOutput(window.openai.toolOutput);
			}

			window.addEventListener('openai:set_globals', (event) => {
				const globalsToolOutput = extractToolOutput(event.detail);
				if (globalsToolOutput) {
					window.openai = window.openai ?? {};
					window.openai.toolOutput = globalsToolOutput;
				}
				hydrateFromToolOutput(globalsToolOutput);
			});

			const hasStructuredValues = (record) =>
				Object.values(record ?? {}).some((value) => trimValue(value).length > 0);

			const buildStructuredOutputSections = (kind, structuredValues) => {
				if (!hasStructuredValues(structuredValues)) return [];
				const get = (key) => trimValue(structuredValues?.[key]);
				const sections = [];
				if (kind === 'bug') {
					const bugId = get('bugId');
					const title = get('title');
					if (bugId && title) {
						sections.push(`Titel: ${bugId} – ${title}`);
					} else if (title) {
						sections.push(`Titel: ${title}`);
					} else if (bugId) {
						sections.push(`Titel: ${bugId}`);
					}
					const labelMap = {
						goal: 'Mål',
						repro: 'Repro',
						expected: 'Forventet',
						actual: 'Faktisk',
						scope: 'Scope',
						constraints: 'Constraints',
						filesInserted: 'Indsatte filer',
					};
					['goal', 'repro', 'expected', 'actual', 'scope', 'constraints', 'filesInserted'].forEach((key) => {
						const value = get(key);
						if (value) sections.push(`${labelMap[key]}: ${value}`);
					});
					return sections;
				}

				const addCommonSections = (keys, labels) => {
					keys.forEach((key, index) => {
						const value = get(key);
						if (value) sections.push(`${labels[index]}: ${value}`);
					});
				};

				if (kind === 'feature' || kind === 'enhancement') {
					const featureId = get('featureId');
					if (featureId) sections.push(`Feature: ${featureId}`);
					const title = get('title');
					if (title) sections.push(`Titel: ${title}`);
					addCommonSections(
						['goal', 'scope', 'constraints', 'filesInserted'],
						['Mål', 'Scope', 'Constraints', 'Indsatte filer'],
					);
					return sections;
				}

				if (kind === 'ui') {
					const featureId = get('featureId');
					if (featureId) sections.push(`UI update: ${featureId}`);
					const title = get('title');
					if (title) sections.push(`Titel: ${title}`);
					addCommonSections(
						['goal', 'scope', 'constraints', 'filesInserted', 'designNotes'],
						['Mål', 'Scope', 'Constraints', 'Indsatte filer', 'Design notes'],
					);
					return sections;
				}

				return sections;
			};

			const formatOutput = (kind, projectName, pastedText, structuredValues = {}) => {
				const lines = [headerLabels[kind] ?? 'PROMPT'];
				if (projectName) lines.push(`Projekt: ${projectName}`);
				const structuredSections = buildStructuredOutputSections(kind, structuredValues);
				if (structuredSections.length) {
					lines.push('', ...structuredSections, '', checklist);
					return lines.join('\n');
				}
				const fallbackInput = trimValue(pastedText) || '(ingen input)';
				lines.push('', 'INPUT:', fallbackInput, '', checklist);
				return lines.join('\n');
			};

			const buildPayload = () => {
				const activeProject = getActiveProject();
				if (!activeProject) return null;
				return {
					kind: kindSelect.value,
					pastedText: pasteInput.value,
					projectName: activeProject.name,
					values: getTrimmedValues(),
				};
			};

			const generateLocally = (payload, { skipStatus = false } = {}) => {
				const kind = payload?.kind ?? kindSelect.value;
				const projectNameRaw = payload?.projectName ?? projectInput.value;
				const projectName = typeof projectNameRaw === 'string' ? projectNameRaw.trim() : '';
				const pastedText = typeof payload?.pastedText === 'string' ? payload.pastedText : pasteInput.value;
				const outputText = formatOutput(kind, projectName, pastedText, payload?.values ?? getTrimmedValues());
				updateOutput(outputText);
				if (!skipStatus) {
					setStatus('Lokalt output genereret');
				}
			};

			const getOutputTextFromResponse = (response) => {
				const directOutput =
					response?.structuredContent?.outputText ??
					response?.structured_content?.outputText ??
					response?.toolOutput?.outputText;
				if (typeof directOutput === 'string') {
					return directOutput;
				}
				const latestGlobalOutput = window.openai?.toolOutput?.outputText;
				return typeof latestGlobalOutput === 'string' ? latestGlobalOutput : undefined;
			};

			const handleToolGeneration = async (payload) => {
				setStatus('Generating…');
				const response = await window.openai.callTool('generate_prompt', payload);
				const outputText = getOutputTextFromResponse(response);
				if (typeof outputText === 'string') {
					updateOutput(outputText);
					setStatus('Done');
					return;
				}
				setStatus('Ingen outputText – bruger fallback', true);
				generateLocally(payload, { skipStatus: true });
			};

			document.getElementById('generateBtn').addEventListener('click', async () => {
				const payload = buildPayload();
				if (!payload) {
					setStatus('Vælg eller opret et projekt først', true);
					return;
				}
				const hasValues = hasStructuredValues(payload.values);
				if (!hasValues && !trimValue(payload.pastedText)) {
					setStatus('Indsæt tekst eller udfyld felter', true);
					return;
				}
				let skipLocalStatus = false;

				if (window.openai?.callTool) {
					try {
						await handleToolGeneration(payload);
						return;
					} catch (error) {
						console.error(error);
						setStatus('Tool fejlede – fallback', true);
						skipLocalStatus = true;
					}
				}

				generateLocally(payload, { skipStatus: skipLocalStatus });
			});

			const copyOutput = async () => {
				const text = outputArea.value;
				if (!text) {
					setStatus('Intet output at kopiere', true);
					return;
				}
				try {
					if (navigator.clipboard?.writeText) {
						await navigator.clipboard.writeText(text);
					} else {
						outputArea.select();
						document.execCommand('copy');
						outputArea.setSelectionRange(0, 0);
					}
					setStatus('Output kopieret');
				} catch (error) {
					console.error(error);
					setStatus('Kunne ikke kopiere', true);
				}
			};

			document.getElementById('copyBtn').addEventListener('click', copyOutput);

			document.getElementById('followUpBtn').addEventListener('click', async () => {
				const text = outputArea.value;
				if (!text) {
					setStatus('Intet output at sende', true);
					return;
				}
				const followUpSender = window.openai?.sendFollowUpMessage ?? window.openai?.sendFollowupMessage;
				if (followUpSender) {
					try {
						await followUpSender({ prompt: text });
						setStatus('Output sendt som follow-up');
					} catch (error) {
						console.error(error);
						setStatus('Kunne ikke sende follow-up', true);
					}
				} else {
					await copyOutput();
				}
			});
		})();
	</script>
</body>
</html>
